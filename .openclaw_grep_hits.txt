./SECURITY.md:4:This repository is public for transparency of SKOpi product logic.
./SECURITY.md:15:- Admin tokens
./.openclaw_filelist.txt:12:docs/token-launch.md
./.openclaw_bigfiles.txt:98:4.0K	./docs/token-launch.md
./src/lib/admin-auth.ts:16:  // Legacy token auth (MVP fallback)
./src/lib/verify-intent.ts:92:      if (ix.program !== "spl-token") continue;
./src/lib/verify-intent.ts:100:        const tokenAmount = Number(info.tokenAmount?.amount ?? 0);
./src/lib/verify-intent.ts:104:        if (tokenAmount === expectedAtomic) amountMatched = true;
./src/lib/verify-intent.ts:109:        const tokenAmount = Number(info.amount ?? 0);
./src/lib/verify-intent.ts:111:        if (tokenAmount === expectedAtomic) amountMatched = true;
./README.md:45:- Token launch verification: `docs/token-launch.md`
./src/app/receipt/[id]/page.tsx:75:  async function copyText(text: string, label: string) {
./src/app/receipt/[id]/page.tsx:80:      alert(`Could not copy ${label}`);
./src/app/receipt/[id]/page.tsx:88:      <h1 style={{ fontSize: 34, marginBottom: 8 }}>SKOpi Receipt</h1>
./src/app/receipt/[id]/page.tsx:130:            <button onClick={() => copyText(intent.id, "Intent ID")}>
./src/app/receipt/[id]/page.tsx:133:            <button onClick={() => copyText(intent.reference_pubkey, "Reference")}>Copy Reference</button>
./src/app/receipt/[id]/page.tsx:135:              <button onClick={() => copyText(intent.tx_signature!, "Tx Signature")}>Copy Tx Signature</button>
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:1:-- SKOpi Airdrop V2 consolidated migration bundle
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:18:  pool_tokens numeric(20,6),
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:30:  bounty_tokens numeric(20,6) not null default 0,
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:60:  total_tokens numeric(20,6) not null default 0,
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:61:  locked_tokens numeric(20,6) not null default 0,
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:62:  claimable_tokens numeric(20,6) not null default 0,
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:106:add column if not exists distributed_tokens numeric(20,6) not null default 0;
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:115:returns table (ok boolean, error text, allocation_id uuid, remaining_tokens numeric)
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:137:    return query select false, 'already_claimed', v_existing, greatest(coalesce(v_campaign.pool_tokens,0) - coalesce(v_campaign.distributed_tokens,0),0);
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:142:    return query select false, 'over_user_cap', null::uuid, greatest(coalesce(v_campaign.pool_tokens,0) - coalesce(v_campaign.distributed_tokens,0),0);
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:146:  if v_campaign.pool_tokens is null then return query select false, 'pool_not_set', null::uuid, null::numeric; return; end if;
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:148:  v_remaining := coalesce(v_campaign.pool_tokens, 0) - coalesce(v_campaign.distributed_tokens, 0);
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:153:  insert into public.airdrop_allocations (campaign_id,user_id,wallet_address,total_tokens,locked_tokens,claimable_tokens,lock_end_at,status)
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:157:  update public.airdrop_campaigns set distributed_tokens = coalesce(distributed_tokens,0) + p_amount where id = p_campaign_id;
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:171:returns table (ok boolean, error text, allocation_id uuid, remaining_tokens numeric)
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:190:  if v_campaign.pool_tokens is null then return query select false, 'pool_not_set', null::uuid, null::numeric; return; end if;
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:192:  select coalesce(sum(total_tokens), 0) into v_wallet_total
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:196:    return query select false, 'over_user_cap', null::uuid, greatest(coalesce(v_campaign.pool_tokens,0) - coalesce(v_campaign.distributed_tokens,0),0);
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:200:  v_remaining := coalesce(v_campaign.pool_tokens, 0) - coalesce(v_campaign.distributed_tokens, 0);
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:205:  insert into public.airdrop_allocations (campaign_id,user_id,wallet_address,total_tokens,locked_tokens,claimable_tokens,lock_end_at,status)
./supabase/migrations_bundle/airdrop_v2_all_pending.sql:209:  update public.airdrop_campaigns set distributed_tokens = coalesce(distributed_tokens,0) + p_amount where id = p_campaign_id;
./supabase/airdrop_v2_fcfs.sql:4:add column if not exists distributed_tokens numeric(20,6) not null default 0;
./supabase/airdrop_v2_fcfs.sql:16:  remaining_tokens numeric
./supabase/airdrop_v2_fcfs.sql:71:    return query select false, 'already_claimed', v_existing, greatest(coalesce(v_campaign.pool_tokens,0) - coalesce(v_campaign.distributed_tokens,0),0);
./supabase/airdrop_v2_fcfs.sql:76:    return query select false, 'over_user_cap', null::uuid, greatest(coalesce(v_campaign.pool_tokens,0) - coalesce(v_campaign.distributed_tokens,0),0);
./supabase/airdrop_v2_fcfs.sql:80:  if v_campaign.pool_tokens is null then
./supabase/airdrop_v2_fcfs.sql:85:  v_remaining := coalesce(v_campaign.pool_tokens, 0) - coalesce(v_campaign.distributed_tokens, 0);
./supabase/airdrop_v2_fcfs.sql:98:    total_tokens,
./supabase/airdrop_v2_fcfs.sql:99:    locked_tokens,
./supabase/airdrop_v2_fcfs.sql:100:    claimable_tokens,
./supabase/airdrop_v2_fcfs.sql:115:  set distributed_tokens = coalesce(distributed_tokens,0) + p_amount
./supabase/airdrop_v2_task_alloc.sql:13:  remaining_tokens numeric
./supabase/airdrop_v2_task_alloc.sql:60:  if v_campaign.pool_tokens is null then
./supabase/airdrop_v2_task_alloc.sql:65:  select coalesce(sum(total_tokens), 0)
./supabase/airdrop_v2_task_alloc.sql:71:    return query select false, 'over_user_cap', null::uuid, greatest(coalesce(v_campaign.pool_tokens,0) - coalesce(v_campaign.distributed_tokens,0),0);
./supabase/airdrop_v2_task_alloc.sql:75:  v_remaining := coalesce(v_campaign.pool_tokens, 0) - coalesce(v_campaign.distributed_tokens, 0);
./supabase/airdrop_v2_task_alloc.sql:88:    total_tokens,
./supabase/airdrop_v2_task_alloc.sql:89:    locked_tokens,
./supabase/airdrop_v2_task_alloc.sql:90:    claimable_tokens,
./supabase/airdrop_v2_task_alloc.sql:105:  set distributed_tokens = coalesce(distributed_tokens,0) + p_amount
./src/app/buy/page.tsx:11:  landingPath?: string | null;
./src/app/buy/page.tsx:47:    "spl-token": intent.usdc_mint,
./src/app/buy/page.tsx:49:    label: "SKOpi Purchase",
./src/app/buy/page.tsx:93:          landingPath: firstTouch?.landingPath || "/buy",
./src/app/buy/page.tsx:108:            landingPath: lastTouch?.landingPath ?? null,
./src/app/buy/page.tsx:178:  async function copyText(text: string, label: string) {
./src/app/buy/page.tsx:183:      alert(`Could not copy ${label}`);
./src/app/buy/page.tsx:189:      <h1 style={{ fontSize: 32, marginBottom: 8 }}>Buy SKOpi (USDC)</h1>
./src/app/buy/page.tsx:240:            <button onClick={() => copyText(intent.treasury_address, "Treasury address")}>Copy Treasury</button>
./src/app/buy/page.tsx:241:            <button onClick={() => copyText(intent.reference_pubkey, "Reference")}>Copy Reference</button>
./src/app/buy/page.tsx:242:            <button onClick={() => copyText(payUrl, "Payment URL")}>Copy Payment URL</button>
./supabase/airdrop_v2_schema.sql:1:-- SKOpi V2 Airdrop Schema (draft v1)
./supabase/airdrop_v2_schema.sql:13:  pool_tokens numeric(20,6),
./supabase/airdrop_v2_schema.sql:25:  bounty_tokens numeric(20,6) not null default 0,
./supabase/airdrop_v2_schema.sql:55:  total_tokens numeric(20,6) not null default 0,
./supabase/airdrop_v2_schema.sql:56:  locked_tokens numeric(20,6) not null default 0,
./supabase/airdrop_v2_schema.sql:57:  claimable_tokens numeric(20,6) not null default 0,
./src/app/airdrop/page.tsx:10:  pool_tokens?: number | null;
./src/app/airdrop/page.tsx:11:  distributed_tokens?: number | null;
./src/app/airdrop/page.tsx:12:  remaining_tokens?: number | null;
./src/app/airdrop/page.tsx:21:  bounty_tokens: string;
./src/app/airdrop/page.tsx:29:  total_tokens: string;
./src/app/airdrop/page.tsx:30:  locked_tokens: string;
./src/app/airdrop/page.tsx:31:  claimable_tokens: string;
./src/app/airdrop/page.tsx:204:      if (alloc?.ok) setResult({ ok: true, message: `Submission accepted and allocated. Remaining pool: ${fmt(alloc.remaining_tokens)}` });
./src/app/airdrop/page.tsx:232:        <h1 style={{ marginBottom: 6 }}>SKOpi Airdrop (V2)</h1>
./src/app/airdrop/page.tsx:245:              {campaigns.map((c) => <tr key={c.id} style={{ borderTop: "1px solid #eee" }}><td style={{ padding: 10 }}>{c.name}</td><td style={{ padding: 10 }}>{fmt(c.pool_tokens)}</td><td style={{ padding: 10 }}>{fmt(c.distributed_tokens)}</td><td style={{ padding: 10 }}><strong>{fmt(c.remaining_tokens)}</strong></td></tr>)}
./src/app/airdrop/page.tsx:256:          <label style={{ display: "grid", gap: 4 }}><span style={{ fontSize: 12, opacity: 0.75 }}>Task</span><select value={taskCode} onChange={(e) => setTaskCode(e.target.value)}><option value="">Select task</option>{tasks.map((t) => <option key={t.id} value={t.code}>{t.title} ({fmt(t.bounty_tokens)} SKOpi) {t.requires_manual ? "· manual" : "· auto"}</option>)}</select></label>
./src/app/airdrop/page.tsx:262:        {selectedTask && <p style={{ marginTop: 10, opacity: 0.82, fontSize: 14 }}>Task: <strong>{selectedTask.title}</strong> · Bounty: <strong>{fmt(selectedTask.bounty_tokens)} SKOpi</strong> · Mode: <strong>{selectedTask.requires_manual ? "Manual review" : "Auto"}</strong></p>}
./src/app/airdrop/page.tsx:263:        {selectedCampaign && <p style={{ marginTop: 4, opacity: 0.82, fontSize: 14 }}>Campaign remaining: <strong>{fmt(selectedCampaign.remaining_tokens)}</strong></p>}
./src/app/airdrop/page.tsx:280:              {allocations.map((a) => <tr key={a.id} style={{ borderTop: "1px solid #eee" }}><td style={{ padding: 10 }}>{new Date(a.created_at).toLocaleString()}</td><td style={{ padding: 10 }}><code>{a.campaign_id.slice(0, 8)}…</code></td><td style={{ padding: 10 }}>{fmt(a.total_tokens)}</td><td style={{ padding: 10 }}>{fmt(a.locked_tokens)}</td><td style={{ padding: 10 }}>{fmt(a.claimable_tokens)}</td><td style={{ padding: 10 }}>{a.status}</td></tr>)}
./docs/transparency-workflow.md:1:# SKOpi Transparency Workflow (Public Verifiability)
./docs/transparency-workflow.md:3:Goal: make it easy for anyone to verify that SKOpi does what it claims.
./docs/transparency-workflow.md:6:- Public-by-default for product logic, tokenomics logic, and allocation rules.
./docs/transparency-workflow.md:17:   - redemption policy (`1 SKOpi = $1 discount`)
./docs/transparency-workflow.md:25:- `.env*` files, service keys, admin tokens, webhook secrets
./docs/transparency-workflow.md:50:## Token launch transparency workflow (when token contract is ready)
./docs/transparency-workflow.md:51:1. Publish token contract/program source in repo under `contracts/` or `programs/`.
./docs/transparency-workflow.md:52:2. Publish deployment config and immutable parameters in `docs/token-launch.md`.
./docs/transparency-workflow.md:53:3. Tag release `token-launch-v1`.
./PROJECT_SCAN_INDEX.md:1:# SKOpi One-Time Scan Index
./PROJECT_SCAN_INDEX.md:41:node_modules/js-tokens
./PROJECT_SCAN_INDEX.md:438:4.0K	./docs/token-launch.md
./PROJECT_SCAN_INDEX.md:464:docs/token-launch.md
./docs/changelog.md:1:# SKOpi Changelog
./docs/changelog.md:9:- Campaign `distributed_tokens` tracking
./docs/changelog.md:32:- Reconciliation endpoint + admin report UI (`distributed_tokens` drift checks).
./docs/changelog.md:43:- Supabase allowlist-based admin auth helper with legacy token fallback.
./docs/token-launch.md:1:# SKOpi Token Launch Transparency Checklist
./docs/token-launch.md:3:Use this when token contract/program is created and deployed.
./docs/token-launch.md:27:Any token-rule changes require:
./src/app/admin/intents/page.tsx:35:  const [token, setToken] = useState("");
./src/app/admin/intents/page.tsx:44:    const t = (useToken ?? token).trim();
./src/app/admin/intents/page.tsx:46:      setError("Enter admin token first");
./src/app/admin/intents/page.tsx:66:      localStorage.setItem("skopi_admin_token", t);
./src/app/admin/intents/page.tsx:76:    const t = token.trim();
./src/app/admin/intents/page.tsx:78:      setError("Enter admin token first");
./src/app/admin/intents/page.tsx:105:    const saved = localStorage.getItem("skopi_admin_token") || "";
./src/app/admin/intents/page.tsx:118:        Auth: Supabase allowlist token (preferred) or legacy ADMIN_READ_TOKEN fallback.
./src/app/admin/intents/page.tsx:125:          value={token}
./package-lock.json:34:        "js-tokens": "^4.0.0",
./package-lock.json:4605:    "node_modules/js-tokens": {
./package-lock.json:4607:      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
./package-lock.json:4768:        "js-tokens": "^3.0.0 || ^4.0.0"
./src/app/admin/airdrops/page.tsx:10:  pool_tokens?: string | null;
./src/app/admin/airdrops/page.tsx:11:  distributed_tokens?: string | null;
./src/app/admin/airdrops/page.tsx:22:  bounty_tokens: string;
./src/app/admin/airdrops/page.tsx:64:  const [token, setToken] = useState("");
./src/app/admin/airdrops/page.tsx:74:  const [reconcileReport, setReconcileReport] = useState<Array<{ campaign_id: string; campaign_name: string; drift_tokens: number; remaining_tokens: number | null; ok: boolean }>>([]);
./src/app/admin/airdrops/page.tsx:115:    const t = (useToken ?? token).trim();
./src/app/admin/airdrops/page.tsx:116:    if (!t) return setError("Enter admin token first");
./src/app/admin/airdrops/page.tsx:123:      localStorage.setItem("skopi_admin_token", t);
./src/app/admin/airdrops/page.tsx:131:    const t = (useToken ?? token).trim();
./src/app/admin/airdrops/page.tsx:140:    const t = (useToken ?? token).trim();
./src/app/admin/airdrops/page.tsx:155:    const t = token.trim();
./src/app/admin/airdrops/page.tsx:156:    if (!t) return setError("Enter admin token first");
./src/app/admin/airdrops/page.tsx:165:          lock_days: Number(lockDays || 90), pool_tokens: poolTokens || null, per_user_cap: capPerUser || null,
./src/app/admin/airdrops/page.tsx:181:    setTaskBounty(String(task.bounty_tokens || "0"));
./src/app/admin/airdrops/page.tsx:196:    const t = token.trim();
./src/app/admin/airdrops/page.tsx:197:    if (!t) return setError("Enter admin token first");
./src/app/admin/airdrops/page.tsx:211:          bounty_tokens: Number(taskBounty || 0),
./src/app/admin/airdrops/page.tsx:232:    const t = token.trim();
./src/app/admin/airdrops/page.tsx:233:    if (!t) return setError("Enter admin token first");
./src/app/admin/airdrops/page.tsx:246:          bounty_tokens: Number(taskBounty || 0),
./src/app/admin/airdrops/page.tsx:269:    const t = token.trim();
./src/app/admin/airdrops/page.tsx:270:    if (!t) return setError("Enter admin token first");
./src/app/admin/airdrops/page.tsx:295:    const t = (useToken ?? token).trim();
./src/app/admin/airdrops/page.tsx:296:    if (!t) return setError("Enter admin token first");
./src/app/admin/airdrops/page.tsx:323:    const t = token.trim();
./src/app/admin/airdrops/page.tsx:324:    if (!t) return setError("Enter admin token first");
./src/app/admin/airdrops/page.tsx:345:    const t = token.trim();
./src/app/admin/airdrops/page.tsx:346:    if (!t) return setError("Enter admin token first");
./src/app/admin/airdrops/page.tsx:380:    const t = token.trim();
./src/app/admin/airdrops/page.tsx:381:    if (!t) return setError("Enter admin token first");
./src/app/admin/airdrops/page.tsx:405:    const saved = localStorage.getItem("skopi_admin_token") || "";
./src/app/admin/airdrops/page.tsx:426:        Auth: Supabase allowlist token (preferred) or legacy ADMIN_READ_TOKEN fallback.
./src/app/admin/airdrops/page.tsx:431:        <input type="password" value={token} onChange={(e) => setToken(e.target.value)} placeholder="Enter ADMIN_READ_TOKEN" style={{ width: "100%", maxWidth: 520, padding: 8, marginBottom: 10 }} />
./src/app/admin/airdrops/page.tsx:443:          <input value={poolTokens} onChange={(e) => setPoolTokens(e.target.value)} placeholder="Pool tokens" />
./src/app/admin/airdrops/page.tsx:465:            <input value={taskTitle} onChange={(e) => setTaskTitle(e.target.value)} placeholder="Follow SKOpi on X" />
./src/app/admin/airdrops/page.tsx:516:            {tasks.map((t) => <tr key={t.id} style={{ borderTop: "1px solid #eee" }}><td style={{ padding: 8 }}><code>{t.code}</code></td><td style={{ padding: 8 }}>{t.title}</td><td style={{ padding: 8 }}>{t.bounty_tokens}</td><td style={{ padding: 8 }}>{t.requires_manual ? "yes" : "no"}</td><td style={{ padding: 8 }}>{t.active ? "yes" : "no"}</td><td style={{ padding: 8, fontSize: 12 }}>{t.requires_https === false ? "http/https" : "https only"} · min:{t.min_evidence_length ?? 10} · domains:{t.allowed_domains?.length ? t.allowed_domains.join("|") : "any"}</td><td style={{ padding: 8, display: "flex", gap: 6 }}><button onClick={() => startEditTask(t)} disabled={loading}>Edit</button><button onClick={() => toggleTaskActive(t)} disabled={loading}>{t.active ? "Disable" : "Enable"}</button></td></tr>)}
./src/app/admin/airdrops/page.tsx:627:                  <td style={{ padding: 8 }}>{r.drift_tokens}</td>
./src/app/admin/airdrops/page.tsx:628:                  <td style={{ padding: 8 }}>{r.remaining_tokens ?? "-"}</td>
./src/app/admin/airdrops/page.tsx:732:              <td style={{ padding: 8 }}>{r.pool_tokens || "-"}</td>
./src/app/admin/airdrops/page.tsx:733:              <td style={{ padding: 8 }}>{r.distributed_tokens || "0"}</td>
./src/app/transparency/page.tsx:6:    { label: "Token Launch Verification", href: "https://github.com/skopiLandToken/skopi/blob/main/docs/token-launch.md" },
./src/app/transparency/page.tsx:13:      <h1>SKOpi Transparency</h1>
./src/app/transparency/page.tsx:15:        We publish core allocation and policy logic so anyone can verify that SKOpi behavior matches what we publicly claim.
./src/app/api/airdrop/campaigns/route.ts:13:      .select("id,name,description,status,start_at,end_at,lock_days,pool_tokens,distributed_tokens,per_user_cap,created_at")
./src/app/api/airdrop/campaigns/route.ts:22:      const pool = c.pool_tokens == null ? null : Number(c.pool_tokens);
./src/app/api/airdrop/campaigns/route.ts:23:      const distributed = Number(c.distributed_tokens || 0);
./src/app/api/airdrop/campaigns/route.ts:25:      return { ...c, remaining_tokens: remaining };
./src/app/start/page.tsx:23:landingPath: window.location.pathname,
./src/app/start/page.tsx:39:<h1 style={{ fontSize: 38, marginBottom: 12 }}>SKOpi Utility Portal</h1>
./src/app/start/page.tsx:41:Utility-first access on Solana. Buy SKOpi with USDC and use it as discount credit in the ecosystem.
./src/app/api/airdrop/claim/route.ts:14:    const amount = Number(body?.amount_tokens || 0);
./src/app/api/airdrop/claim/route.ts:24:      return NextResponse.json({ ok: false, error: "amount_tokens must be > 0" }, { status: 400 });
./src/app/api/airdrop/claim/route.ts:49:          remaining_tokens: row.remaining_tokens ?? null,
./src/app/api/airdrop/claim/route.ts:59:      remaining_tokens: row.remaining_tokens,
./src/app/api/purchase-intents/route.ts:21:landingPath?: string | null;
./src/app/api/purchase-intents/route.ts:36:landingPath?: string | null;
./src/app/api/purchase-intents/route.ts:86:ft_landing_path: body.landingPath ?? null,
./src/app/api/purchase-intents/route.ts:94:lt_landing_path: body.lastTouch?.landingPath ?? null,
./src/app/api/airdrop/submit-task/route.ts:92:      .select("id,code,bounty_tokens,requires_manual,max_per_user,allowed_domains,requires_https,min_evidence_length,active")
./src/app/api/airdrop/submit-task/route.ts:180:      const alloc = await allocateIfEligible(campaignId, wallet, Number(task.bounty_tokens), userId);
./src/app/api/airdrop/submit-task/route.ts:193:        allocation: { ok: true, allocation_id: alloc.allocation_id, remaining_tokens: alloc.remaining_tokens },
./src/app/api/airdrop/allocations/route.ts:20:      .select("id,campaign_id,wallet_address,total_tokens,locked_tokens,claimable_tokens,lock_end_at,status,tx_signature,created_at,updated_at")
./src/app/api/admin/airdrop/submissions/route.ts:70:    const results: Array<{ submission_id: string; ok: boolean; error?: string; allocation_id?: string; remaining_tokens?: number }> = [];
./src/app/api/admin/airdrop/submissions/route.ts:112:        .select("id,bounty_tokens")
./src/app/api/admin/airdrop/submissions/route.ts:121:      const alloc = await allocate(sub.campaign_id, sub.wallet_address, Number(task.bounty_tokens), sub.user_id || null);
./src/app/api/admin/airdrop/submissions/route.ts:140:        results.push({ submission_id: submissionId, ok: true, allocation_id: alloc.allocation_id, remaining_tokens: alloc.remaining_tokens });
./src/app/api/admin/airdrop/submissions/route.ts:148:          metadata: { remaining_tokens: alloc.remaining_tokens, notes: notes || "Approved by reviewer" },
./src/app/api/airdrop/tasks/route.ts:19:      .select("id,campaign_id,code,title,description,bounty_tokens,requires_manual,max_per_user,allowed_domains,requires_https,min_evidence_length,active,sort_order")
./src/app/api/admin/airdrop/tasks/route.ts:25:      .select("id,campaign_id,code,title,description,bounty_tokens,requires_manual,max_per_user,allowed_domains,requires_https,min_evidence_length,active,sort_order,created_at,updated_at")
./src/app/api/admin/airdrop/tasks/route.ts:49:    bounty_tokens: body?.bounty_tokens != null ? Number(body.bounty_tokens) : undefined,
./src/app/api/admin/airdrop/tasks/route.ts:73:    if (!Number.isFinite(Number(payload.bounty_tokens ?? 0)) || Number(payload.bounty_tokens ?? 0) < 0) {
./src/app/api/admin/airdrop/tasks/route.ts:74:      return NextResponse.json({ ok: false, error: "bounty_tokens must be >= 0" }, { status: 400 });
./src/app/api/admin/airdrop/tasks/route.ts:82:      bounty_tokens: Number(payload.bounty_tokens ?? 0),
./src/app/api/admin/airdrop/tasks/route.ts:95:      .select("id,campaign_id,code,title,bounty_tokens,requires_manual,max_per_user,allowed_domains,requires_https,min_evidence_length,active,sort_order,created_at")
./src/app/api/admin/airdrop/tasks/route.ts:129:    if (payload.bounty_tokens !== undefined) {
./src/app/api/admin/airdrop/tasks/route.ts:130:      if (!Number.isFinite(Number(payload.bounty_tokens)) || Number(payload.bounty_tokens) < 0) {
./src/app/api/admin/airdrop/tasks/route.ts:131:        return NextResponse.json({ ok: false, error: "bounty_tokens must be >= 0" }, { status: 400 });
./src/app/api/admin/airdrop/tasks/route.ts:133:      update.bounty_tokens = Number(payload.bounty_tokens);
./src/app/api/admin/airdrop/tasks/route.ts:147:      .select("id,campaign_id,code,title,description,bounty_tokens,requires_manual,max_per_user,allowed_domains,requires_https,min_evidence_length,active,sort_order,updated_at")
./src/app/api/admin/airdrop/reconcile/route.ts:20:      .select("id,name,status,pool_tokens,distributed_tokens,created_at")
./src/app/api/admin/airdrop/reconcile/route.ts:34:        .select("total_tokens,status")
./src/app/api/admin/airdrop/reconcile/route.ts:39:      const allocationSum = (allocs || []).reduce((sum, a) => sum + Number(a.total_tokens || 0), 0);
./src/app/api/admin/airdrop/reconcile/route.ts:40:      const distributed = Number(c.distributed_tokens || 0);
./src/app/api/admin/airdrop/reconcile/route.ts:41:      const pool = c.pool_tokens == null ? null : Number(c.pool_tokens);
./src/app/api/admin/airdrop/reconcile/route.ts:49:        pool_tokens: pool,
./src/app/api/admin/airdrop/reconcile/route.ts:50:        distributed_tokens: distributed,
./src/app/api/admin/airdrop/reconcile/route.ts:51:        allocations_total_tokens: Number(allocationSum.toFixed(6)),
./src/app/api/admin/airdrop/reconcile/route.ts:52:        drift_tokens: drift,
./src/app/api/admin/airdrop/reconcile/route.ts:53:        remaining_tokens: remaining,
./src/app/api/admin/airdrop/campaigns/route.ts:18:      .select("id,name,description,status,start_at,end_at,lock_days,pool_tokens,distributed_tokens,per_user_cap,created_at,updated_at")
./src/app/api/admin/airdrop/campaigns/route.ts:50:      pool_tokens: body?.pool_tokens ?? null,
./src/app/api/admin/airdrop/campaigns/route.ts:52:      distributed_tokens: 0,
./src/app/api/admin/airdrop/campaigns/route.ts:58:      .select("id,name,status,lock_days,pool_tokens,distributed_tokens,created_at")
./src/app/api/admin/airdrop/export/route.ts:50:        .select("id,campaign_id,user_id,wallet_address,total_tokens,locked_tokens,claimable_tokens,lock_end_at,status,tx_signature,created_at,updated_at")
./src/app/api/admin/airdrop/export/route.ts:57:      const headers = ["id","campaign_id","user_id","wallet_address","total_tokens","locked_tokens","claimable_tokens","lock_end_at","status","tx_signature","created_at","updated_at"];
./src/app/api/admin/airdrop/export/route.ts:65:        .select("id,name,status,pool_tokens,distributed_tokens,per_user_cap,lock_days,start_at,end_at,created_at,updated_at")
./src/app/api/admin/airdrop/export/route.ts:70:      const headers = ["id","name","status","pool_tokens","distributed_tokens","per_user_cap","lock_days","start_at","end_at","created_at","updated_at"];
